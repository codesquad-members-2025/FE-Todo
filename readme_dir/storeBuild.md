# store 기능 구현 위한 리팩토링 노트

## 기존의 흐름

- 기존에는 store라는 개념없이 사용자가 데이터의 상태를 조작하고, dom의 상태를 조작했다.

- 1️⃣ 웹 페이지 새로 고침시

1. fetch()로 목업 데이터 불러오기
2. localStorage.getItem("task")으로 저장된 데이터 불러오기
3. mergeObjects()로 두 데이터를 합침

- 2️⃣ 사용자가 할 일을 추가하면

1. store라는 개념없이 바로 localStorage에 저장
2. drawModal()을 실행해서 추가할 위치를 찾고 찾은 위치에 기존의 요소에 추가

- 3️⃣ 삭제 수정도 마찬가지로

1. localStorage에서 직접 데이터를 수정
2. UI삭제도 직접 dom을 탐색해서 해당 요소를 찾아서 삭제

- 🤯이 방식의 문제점

1. 데이터 관리가 중구난방: localStorage, fetchData(), mergeObjects()가 다 흩어져 있음
2. DOM을 매번 지우고 다시 그림
3. 🧨**데이터 추가 이벤트가 발생하면 그 위치를 찾기 위해 DOM탐색을 이벤트가 발생할때 마다 탐색을 실행한다.**🧨
4. 상태(state)를 추적하기 어려움: 사용자가 할 일을 추가/삭제했을 때 데이터 흐름이 불명확

## 🤩개선될 동작 흐름🤩

- 🎯 웹 페이지 새로 고침 시 동작

- 1️⃣ 브라우저 실행 시

1. fetch()로 목업 데이터 불러오기
2. localStorage.getItem("task")으로 저장된 데이터 불러오기
3. mergeObjects()로 두 데이터를 합침

- 2️⃣ 데이터 저장은?

4. 병합된 데이터를 **store** 에 저장 👉스토어는 중앙저장소 역할

- 3️⃣ renderCards()실행

5. **store**에 있는 데이터만 보고 UI를 그린다.

---

- 🎯 사용자가 할 일을 추가 할 때 동작

1. 사용자가 할 일을 입력
2. 상태값을 읽어서 store의 상태에 추가. (기존에 웹페이지가 실행될때 읽어왔기에 기존의 store에 데이터를 추가한다.)
3. store에서 자동으로 localStorage에 데이터를 새로 교체한다.
4. renderCards()가 실행되면서 자동으로 UI를 업데이트 한다.(🔥이때 ui업데이트는 하나씩 DOM을 변경하지 말고 가상돔을 이용한다.)

- 🎯 할 일을 삭제할 때 동작

1. 삭제버튼을 누르면
2. store에서 해당 데이터를 삭제한다.
3. store에서 자동으로 localStorage에 데이터를 업데이트 한다.
4. renderCards()가 자동으로 UI를 업데이트 한다.

## 기존의 renderCard()의 흐름 수정

- 😩기존에는 카드가 추가, 삭제 되면 삭제해야 할 위치를 찾기 위해 DOM을 탐색하고, 그 위치에 요소를 삭제했다.

- 이 방식은 너무 복잡하고 이벤트가 발생할떄마다 위치를 찾기위해 DOM을 탐색하고, 요소를 넣어야 한다.

- ☺️ 전체의 카드 모달이 있는 HTML정보를 템플릿으로 작성후, 부품 교체하듯이 수정된 템플릿을 갈아 끼워야한다!

## renderCard()의 흐름!

1. store에서 데이터 **전체**를 입력받는다.

```JSON
{
  "todo": {
    "1741845913823": {
      "title": "할 일 제목",
      "content": "할 일 내용"
    },
    "1741786771823": {
      "title": "공부 해야 할 것",
      "content": "수학 복습"
    }
  },
  "doing": { ... },
  "done": { ... }
}
```

2. ~~데이터 전체에서 각 키인 데이터 타입을 순환한다(데이터 순환)~~

   - ~~키의 안에서 id인 키를 순회하면서 하나의 카드 데이터를 카드 템플릿에 넣어 카드를 생성한다.~~

3. 전체 칸반 템플릿에서 각 3개의 칼럼(카드 뭉치)를 입력받아 넣는다.

4. ~~완성된 칸반 테플릿을 기존의 칸반과 교체한다.~~

- 추가된 **특정 카드 정보만** 탬플릿으로 만들어서 기존의 위치에 끼워넣는다.
  -> 전체 요소를 (칸반 템플릿 교체)교체하는 방식이면 많은 정보를 바꾸게 되는데 이거는 많은 비용이 든다. 그리고 눈에는 똑같은 정보가 교체된다고 해도 새로운 정보가 넣어지는 거라서 이건 많은 비용이 든다.

- 그러면?
  - ➡️ 기존에 카드를 넣는 방식(특정 위치에 타겟 카드만 추가 or 삭제하는 방식 )으로 한다.

## 기능별 모듈화

1. 데이터를 가져오는 기능 (fetchMockData(), getLocalStorageData())
2. 데이터를 병합하는 기능 (mergeObjects())
3. store에 데이터를 저장하고 관리하는 기능 (store.js)
4. UI를 업데이트하는 기능 (renderCards())

## 스토어 모듈 기능

- ❓NAGO 님은 따로 js 변수에 store로 두신듯? -> 나는 localStorage를 활용한다.(데이터 영구성 중요) ~~투두리스트인데 데이터가 왜 날라ㄱ~~
- 모든 데이터를 불러와야한다.
- 데이터 상태 변경 발생시 데이터 상태 변경후, 스토어에 업데이트 해야한다.
- 사용자에 이벤트 발생시 각 분기에 맞게 UI 수정(이때 어쩔수 없는 dom 조작은 하지만 반복적인 DOM 조작은 피한다.)

## 리팩토링 최종 목표

- ❗️ 일단 store의 개념 도입후, 사용자가 직접 이벤트 발생시 데이터 조작, ui 조작하게 하지 않는다.

- 사용자의 이벤트 발생 사실을 store에게 알리고(상태 변경) 이를 소식받은 store가 데이터 관리, ui관리를 하게끔 리팩토링 목표로 잡는다.
