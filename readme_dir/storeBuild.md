# store 기능 구현 위한 리팩토링 노트

## 기존의 흐름

- 기존에는 store라는 개념없이 사용자가 데이터의 상태를 조작하고, dom의 상태를 조작했다.

- 1️⃣ 웹 페이지 새로 고침시

1. fetch()로 목업 데이터 불러오기
2. localStorage.getItem("task")으로 저장된 데이터 불러오기
3. mergeObjects()로 두 데이터를 합침

- 2️⃣ 사용자가 할 일을 추가하면

1. store라는 개념없이 바로 localStorage에 저장
2. drawModal()을 실행해서 추가할 위치를 찾고 찾은 위치에 기존의 요소에 추가

- 3️⃣ 삭제 수정도 마찬가지로

1. localStorage에서 직접 데이터를 수정
2. UI삭제도 직접 dom을 탐색해서 해당 요소를 찾아서 삭제

- 🤯이 방식의 문제점

1. 데이터 관리가 중구난방: localStorage, fetchData(), mergeObjects()가 다 흩어져 있음
2. DOM을 매번 지우고 다시 그림
3. 🧨**데이터 추가 이벤트가 발생하면 그 위치를 찾기 위해 DOM탐색을 이벤트가 발생할때 마다 탐색을 실행한다.**🧨
4. 상태(state)를 추적하기 어려움: 사용자가 할 일을 추가/삭제했을 때 데이터 흐름이 불명확

## 🤩개선될 동작 흐름🤩

- 🎯 웹 페이지 새로 고침 시 동작

- 1️⃣ 브라우저 실행 시

1. fetch()로 목업 데이터 불러오기
2. localStorage.getItem("task")으로 저장된 데이터 불러오기
3. mergeObjects()로 두 데이터를 합침

- 2️⃣ 데이터 저장은?

4. 병합된 데이터를 **store** 에 저장 👉스토어는 중앙저장소 역할

- 3️⃣ renderCards()실행

5. **store**에 있는 데이터만 보고 UI를 그린다.

---

- 🎯 사용자가 할 일을 추가 할 때 동작

1. 사용자가 할 일을 입력
2. 상태값을 읽어서 store의 상태에 추가. (기존에 웹페이지가 실행될때 읽어왔기에 기존의 store에 데이터를 추가한다.)
3. store에서 자동으로 localStorage에 데이터를 새로 교체한다.
4. renderCards()가 실행되면서 자동으로 UI를 업데이트 한다.(🔥이때 ui업데이트는 하나씩 DOM을 변경하지 말고 가상돔을 이용한다.)

- 🎯 할 일을 삭제할 때 동작

1. 삭제버튼을 누르면
2. store에서 해당 데이터를 삭제한다.
3. store에서 자동으로 localStorage에 데이터를 업데이트 한다.
4. renderCards()가 자동으로 UI를 업데이트 한다.

## 기존의 renderCard()의 흐름 수정

- 😩기존에는 카드가 추가, 삭제 되면 삭제해야 할 위치를 찾기 위해 DOM을 탐색하고, 그 위치에 요소를 삭제했다.

- 이 방식은 너무 복잡하고 이벤트가 발생할떄마다 위치를 찾기위해 DOM을 탐색하고, 요소를 넣어야 한다.

- ☺️ 전체의 카드 모달이 있는 HTML정보를 템플릿으로 작성후, 부품 교체하듯이 수정된 템플릿을 갈아 끼워야한다!

## renderCard()의 흐름!

1. store에서 데이터 **전체**를 입력받는다.

```JSON
{
  "todo": {
    "1741845913823": {
      "title": "할 일 제목",
      "content": "할 일 내용"
    },
    "1741786771823": {
      "title": "공부 해야 할 것",
      "content": "수학 복습"
    }
  },
  "doing": { ... },
  "done": { ... }
}
```

2. ~~데이터 전체에서 각 키인 데이터 타입을 순환한다(데이터 순환)~~

   - ~~키의 안에서 id인 키를 순회하면서 하나의 카드 데이터를 카드 템플릿에 넣어 카드를 생성한다.~~

3. 전체 칸반 템플릿에서 각 3개의 칼럼(카드 뭉치)를 입력받아 넣는다.

4. ~~완성된 칸반 테플릿을 기존의 칸반과 교체한다.~~

- 추가된 **특정 카드 정보만** 탬플릿으로 만들어서 기존의 위치에 끼워넣는다.
  -> 전체 요소를 (칸반 템플릿 교체)교체하는 방식이면 많은 정보를 바꾸게 되는데 이거는 많은 비용이 든다. 그리고 눈에는 똑같은 정보가 교체된다고 해도 새로운 정보가 넣어지는 거라서 이건 많은 비용이 든다.

- 그러면?
  - ➡️ 기존에 카드를 넣는 방식(특정 위치에 타겟 카드만 추가 or 삭제하는 방식 )으로 한다.

## 기능별 모듈화

1. 데이터를 가져오는 기능 (fetchMockData(), getLocalStorageData())
2. 데이터를 병합하는 기능 (mergeObjects())
3. store에 데이터를 저장하고 관리하는 기능 (store.js)
4. UI를 업데이트하는 기능 (renderCards())

## 스토어 모듈 기능

- ❓NAGO 님은 따로 js 변수에 store로 두신듯? -> 나는 localStorage를 활용한다.(데이터 영구성 중요) ~~투두리스트인데 데이터가 왜 날라ㄱ~~
- 모든 데이터를 불러와야한다.
- 데이터 상태 변경 발생시 데이터 상태 변경후, 스토어에 업데이트 해야한다.
- 사용자에 이벤트 발생시 각 분기에 맞게 UI 수정(이때 어쩔수 없는 dom 조작은 하지만 반복적인 DOM 조작은 피한다.)

## 리팩토링 최종 목표

- ❗️ 일단 store의 개념 도입후, 사용자가 직접 이벤트 발생시 데이터 조작, ui 조작하게 하지 않는다.

- 사용자의 이벤트 발생 사실을 store에게 알리고(상태 변경) 이를 소식받은 store가 데이터 관리, ui관리를 하게끔 리팩토링 목표로 잡는다.

1. web

- 이벤트 발생 감지,

2. store

- store 데이터 관리

3. component

- ui 관리

-> 그러면 이런 이벤트 전달은 누가 해?

4. controller개념 등장

- web 상태 변경시 sotre에 전달
- store 데이터 변경시 ~~component에 ui수정 전달~~ 자동으로 옵저버가 감지해서 컴포넌트에 전달

5. 옵저버

- 이거 구현이 포인트..?
- 일단 store의 데이터 변화시 작동해야 하니까 sotre안에서 작동해야한다.
- store에 데이터가 왔다는건 삭제 or 추가시에 옵저버 실행
- 데이터 추가시 -> 옵저버의 데이터 추가 함수 실행(상태 변화를 알리는 것)
- 데이터 삭제시 -> 옵저버의 데이터 삭제 함수 실행
- 옵저버에서 변형 사실을 컴포넌트에 알린다.

------------------------------------------------------------------------------------- 다시 설계

## 내가 생각한 이상적인 흐름

- 일단 하나의 공간에서 여러가지 일을 하면 안된다.

### web

웹 페이지에서 발생하는 이벤트 감지역할

- 이벤트 발생(분기)에 따라 다른 컨트롤러 호출
- 상태 변경 , 모달 보여주기 ...

### controller(“이벤트 중개자”)

web에서의 이벤트 발생시 작동하는 로직이 모여있는 곳(이때 행동을 전달하는 역할을 한다.)
store & component와 연결 (데이터 전달 & UI 제어)

- 이벤트 핸들러가 있는곳
- web에서 컨트롤러의 함수를 호출한다.
- 컨트롤러에는 모달을 보여주는 기능, 상태의 변경을 store에 전달하는 기능을 해준다.

📢 사용자 클릭 (web)
⬇
🎮 컨트롤러 → store (데이터 추가/삭제 요청)
⬇
🎮 컨트롤러 → component (UI 변경 요청 ex. 모달 띄우기)

### store

데이터의 상태 관리

- 데이터의 변경을 담당한다.

📦 store (데이터 변경)
⬇
👀 옵저버 (변경 감지 & UI 업데이트 요청)
⬇
🎨 component (UI 업데이트 실행)

### component

ui 변경을 담당한다.

### 최종 흐름

📢 사용자 클릭 (web)
⬇
🎮 컨트롤러 → store (데이터 변경 요청)
⬇
📦 store (데이터 변경)
⬇
👀 옵저버 (변경 감지 & UI 업데이트 요청)
⬇
🎨 component (UI 업데이트 실행)

➡️ 이렇게 되면 각 모듈은 정말 하나의 행동만 하게된다.
중요하게 생각하는건 기존에는 컨트롤러가 store에서 상태가 변경되면 컴포넌트 조작까지 전달했지만, 옵저버가 이 역할을 대신 부담해서 역할이 분리되었다.
